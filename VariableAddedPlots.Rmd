# `UN11` example (**alr4**)

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE,
                      warning = FALSE,
                      cache = TRUE)
```

p. 54 Figure 3.3(a)

1. Compute the regression of `lifeExpF` on `log(ppgdp)`:

```{r}
library(alr4)
library(tidyverse)
library(plotly)
u <- UN11
```


```{r}
mod1 <- lm(u$lifeExpF ~ log(u$ppgdp))
mod1
summary(mod1)$r.squared
u$`Model 1 residuals` <- ifelse(mod1$residuals > 0, "higher than expected lifeExpF", "lower than expected lifeExpF")

```

```{r}
g <- ggplot(u, aes(log(ppgdp), lifeExpF, label = rownames(u), color = `Model 1 residuals`)) + 
  geom_point() +  
  geom_smooth(aes(group = 1), method = "lm", se=FALSE, show.legend =FALSE) +
  ggtitle("Model 1")
g

```


**The residuals from this model are the part of the response `lifeExpF` not explained by the regression on `log(ppgdp)`**


2. Compute the regression of `fertility` on `log(ppgdp)`.

**The residuals from this model are the part of the new regressor `fertility` not explained by the regression on `log(ppgdp)`**
```{r}
mod2 <- lm(u$fertility ~ log(u$ppgdp))
mod2
summary(mod2)$r.squared

g <- ggplot(u, aes(log(ppgdp), fertility, label = rownames(u), color = `Model 1 residuals`)) + 
  geom_point() +
  geom_smooth(aes(group = 1), method = "lm", se=FALSE, show.legend = FALSE) +
  ggtitle("Model 2")
g
```

3. The added variable plot is of the unexplained part of the response from (1) on the unexplained part of the added regressor from (2).

```{r}
residdf <- tibble::tibble(r1 = mod1$residuals,
                          r2 = mod2$residuals)
g <- ggplot(residdf, aes(r2, r1)) + 
  geom_point() +
  xlab(expression(paste(hat(e), " from fertility on log(ppgdp)"))) +
  ylab(expression(paste(hat(e), " from lifeExpF on log(ppgdp)"))) +
  geom_smooth(method = "lm", se=FALSE)
g
```
The slope of this regression line is:

```{r}
lm(residdf$r1~residdf$r2)
```
It is the same as the coefficient of $\hat{\beta_2}$ with both regressors:

```{r}
u$logppgdp <- log(u$ppgdp)
mod <- lm(lifeExpF ~ fertility + logppgdp, data = u)
mod

# predict over sensible grid of values
# 
#f <- unique(u$fertility)
#g <- unique(u$logppgdp)
f <- 0:8
g <- 5:11
grid <- expand.grid(f, g)
d <- setNames(data.frame(grid), c("fertility", "logppgdp"))
vals <- predict(mod, newdata = d)

# form matrix and give to plotly
# x has to be the second variable and y the first or
# do m <- m(t)
m <- matrix(vals, nrow = 9, ncol = 7)

um <- broom::augment(mod) %>% 
  rename(country = .rownames) %>% 
  mutate(text = paste(country, "<br>lifeExpF: ", lifeExpF, "<br>lifeExpF predicted", round(.fitted, 2)),
         resids = ifelse(.resid < 0, "-", "+"))
# https://plotly.com/r/line-and-scatter/

plot_ly() %>% 

  add_trace(data = um, type = "scatter3d", mode = "markers", 
            x = ~logppgdp, y = ~fertility, z = ~lifeExpF, 
# only 8 symbols available for scatter3d: circle, circle-open,
# square, square-open, diamond, diamond-open, cross, x
# instead using pch symbols, see:
# https://plotly-r.com/scatter-traces.html
            color = I("red"),
            marker = list(size = 3),
# https://plotly.com/r/hover-text-and-formatting/              
            text = ~text, hoverinfo = "text") %>% 
  
# https://plotly.com/r/3d-hover/#customize-hover-for-spikelines
  layout(scene = list(xaxis = list(showspikes = FALSE),
                      yaxis = list(showspikes = FALSE),
                      zaxis = list(showspikes = FALSE)))  %>%
  add_text(data = um,
           x = ~logppgdp, y = ~fertility, z = ~lifeExpF,
           text = ~resids)  %>%
  
  add_surface(x = ~g, y = ~f, z = ~m,
              opacity = .5, showscale = FALSE, 
              hoverinfo = "none", 
# https://plotly.com/r/3d-hover/#customize-hover-for-surface-contours
              color = I("black"),
              contours = list(x = list(highlight = FALSE),
                              y = list(highlight = FALSE),
                              z = list(highlight = FALSE)))



```


```{r}

```



```{r}
plot_ly() %>% 
  add_markers(
    data = iris,
    x = ~Sepal.Length, y = ~Petal.Length, z = ~Sepal.Width,
    color = I("black"),
    symbol = ~Species, 
    symbols = c("triangle-up", "diamond", "pentagon")
  )


```

```{r, echo = FALSE, eval = FALSE}
# https://community.plotly.com/t/3d-scatter-3d-regression-line/4149
# fit model
m <- lm(mpg ~ wt + disp, data = mtcars)

# predict over sensible grid of values
wts <- unique(mtcars$wt)
disps <- unique(mtcars$disp)
grid <- with(mtcars, expand.grid(wts, disps))
d <- setNames(data.frame(grid), c("wt", "disp"))
vals <- predict(m, newdata = d)

# form matrix and give to plotly
m <- matrix(vals, nrow = length(unique(d$wt)), ncol = length(unique(d$disp)))

plot_ly() %>% add_surface(x = ~disps, y = ~wts, z = ~m) %>%
  add_markers(data = mtcars, x = ~disp, y = ~wt, z = ~mpg)
```



```{r, eval=FALSE, echo=FALSE}
# how to label axes in base R
plot(mod1$residuals ~ mod2$residuals, pch = 16, cex = .75, xlab = expression(paste(hat(e), " from fertility on log(ppgdp)")), ylab = expression(paste(hat(e), " from lifeExpF on log(ppgdp)")), las = 1)
abline(lm(mod1$residuals ~ mod2$residuals))

# how to label axes in plotly
ggplotly(g) %>%  layout(
    xaxis = list(title = TeX("\\hat{e} \\text{ from fertility on log(ppgdp)}")),
    yaxis = list(title = TeX("\\hat{e} \\text{ from lifeExpF on log(ppgdp)}"))) %>%
  config(mathjax = "cdn")
```


